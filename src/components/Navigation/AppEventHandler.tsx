import notifee, {Event, EventType} from '@notifee/react-native';
import {useLinkTo} from '@react-navigation/native';
import {useEffect} from 'react';
import {Linking} from 'react-native';

import {useSwiftarrQueryClient} from '#src/Context/Contexts/SwiftarrQueryClientContext.ts';
import {PressAction} from '#src/Enums/Notifications.ts';
import {getUrlForNotificationEvent} from '#src/Libraries/Notifications/SocketNotification.ts';
import {useUserNotificationDataQuery} from '#src/Queries/Alert/NotificationQueries.ts';

/**
 * High level functional component to handle app events that are generated by reactions to notifications.
 * Usually used when the user taps on a notification or hits one of its action buttons.
 */
export const AppEventHandler = () => {
  const linkTo = useLinkTo();
  const {refetch: refetchUserNotificationData} = useUserNotificationDataQuery({enabled: false});
  const {apiGet} = useSwiftarrQueryClient();

  // Foreground events occur when the app is front and center in the users view.
  // This has to be a useEffect otherwise the navigator could be used before it's
  // initialized. Which still functions but throws an error.
  useEffect(() => {
    const handleForegroundEvent = async (event: Event) => {
      console.log('[AppEventHandler.tsx] handleForegroundEvent responding to event', event.type);

      // When I made notification permissions optional, I started seeing EventType.DELIVERED events make
      // it in here. This caused the app to launch whenever a notification was received which is unacceptable.
      // Limiting the actions that can trigger the app made it better.
      if (event.type === EventType.DELIVERED || event.type === EventType.DISMISSED) {
        console.log('[AppEventHandler.tsx] onBackgroundEvent skipping delivered or dismissed event');
        return;
      }

      const {notification, pressAction} = event.detail;

      // Look for Mark As Read press actions. This will fire off a request to the server which
      // assumes the user read the content and updates its state accordingly. Refresh the UND
      // so that we can pick up the appropriate state.
      if (pressAction?.id === PressAction.markAsRead) {
        console.info('[AppEventHandler.tsx] handleForegroundEvent is marking as read.');
        if (notification?.data) {
          await apiGet(notification.data.markAsReadUrl.toString());
          await refetchUserNotificationData();
        }
        return;
      }

      // The default response is to then navigate the user somewhere.
      const url = getUrlForNotificationEvent(event.type, notification, pressAction);
      if (url) {
        console.log('[AppEventHandler.tsx] handleForegroundEvent responding to url', url);
        linkTo(url);
      } else {
        console.warn('[AppEventHandler.tsx] handleForegroundEvent unable to determine URL.');
      }
    };

    // We get the unsubscribe function returned from registering the handler.
    const unsubscribe = notifee.onForegroundEvent(handleForegroundEvent);

    return () => {
      unsubscribe();
    };
  }, [apiGet, linkTo, refetchUserNotificationData]);

  // Background events occur when the app is still running but not in the users view.
  // The OS may kill the app at any time.
  notifee.onBackgroundEvent(async (event: Event) => {
    console.log('[AppEventHandler.tsx] onBackgroundEvent responding to event', event.type);

    // When I made notification permissions optional, I started seeing EventType.DELIVERED events make
    // it in here. This caused the app to launch whenever a notification was received which is unacceptable.
    // Limiting the actions that can trigger the app made it better.
    if (event.type === EventType.DELIVERED || event.type === EventType.DISMISSED) {
      console.log('[AppEventHandler.tsx] onBackgroundEvent skipping delivered or dismissed event');
      return;
    }

    const {notification, pressAction} = event.detail;

    // Look for Mark As Read press actions. This will fire off a request to the server which
    // assumes the user read the content and updates its state accordingly. Refresh the UND
    // so that we can pick up the appropriate state.
    if (pressAction?.id === PressAction.markAsRead) {
      console.info('[AppEventHandler.tsx] handleForegroundEvent is marking as read.');
      if (notification?.data) {
        await apiGet(notification.data.markAsReadUrl.toString());
        await refetchUserNotificationData();
      }
      return;
    }

    // The default response is to then navigate the user somewhere.
    const url = getUrlForNotificationEvent(event.type, notification, pressAction);
    if (url) {
      const linkingUrl = `tricordarr:/${url}`;
      console.log('[AppEventHandler.tsx] onBackgroundEvent launching url', linkingUrl);
      await Linking.openURL(linkingUrl); // url starts with a /, so only add one.
    } else {
      console.warn('[AppEventHandler.tsx] onBackgroundEvent event was not a respondable action. Skipping...');
      await Linking.openURL('tricordarr://home');
    }
  });

  // Void is not a valid React component.
  return null;
};
